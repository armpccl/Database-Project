import Order from '../models/Order.js';
import OrderItem from '../models/OrderItem.js';
import Cart from '../models/Cart.js';
import CartItem from '../models/CartItem.js';
import Book from '../models/Book.js';
import Shipping from '../models/Shipping.js'; // Assuming Shipping model
import db from '../config/db.js';

// Helper for unique order ID / tracking number if not auto-generated by DB
// THIS IS A PLACEHOLDER - Use robust unique ID generation in production
async function generateUniqueOrderID() {
    let isUnique = false; let newId;
    while(!isUnique) {
        newId = Math.floor(1000000 + Math.random() * 9000000);
        const [rows] = await db.query('SELECT orderID FROM Orders WHERE orderID = ?', [newId]);
        if (rows.length === 0) isUnique = true;
    }
    return newId;
}
async function generateUniqueTrackingNumber() {
    let isUnique = false; let newId;
    const prefix = "TRK";
    while(!isUnique) {
        newId = prefix + Math.floor(100000000 + Math.random() * 900000000);
        const [rows] = await db.query('SELECT tracking_number FROM Shipping WHERE tracking_number = ?', [newId]);
        if (rows.length === 0) isUnique = true;
    }
    return newId;
}


export const createOrder = async (req, res, next) => {
  const connection = await db.getConnection();
  try {
    await connection.beginTransaction();
    const userID = req.user.userID;
    const { payment_method } = req.body; // 'qr_code' or 'credit_card'

    if (!payment_method) {
      res.status(400);
      throw new Error('Payment method is required.');
    }

    const cart = await Cart.findByUserId(userID, connection);
    if (!cart || cart.total_price <= 0) {
      res.status(400);
      throw new Error('Cart is empty or invalid.');
    }

    const cartItems = await CartItem.findByCartId(cart.cartID, connection);
    if (cartItems.length === 0) {
      res.status(400);
      throw new Error('No items in cart to order.');
    }

    // Check stock for all items
    for (const item of cartItems) {
      const book = await Book.findById(item.bookID, connection);
      if (!book || book.stock < item.quantity) {
        throw new Error(`Insufficient stock for book: ${book ? book.book_name : item.bookID}. Available: ${book ? book.stock : 0}, Required: ${item.quantity}`);
      }
    }

    // If orderID is not AUTO_INCREMENT:
    const newOrderID = await generateUniqueOrderID(); // Placeholder

    // Create Order
    const orderData = {
      orderID: newOrderID, // Provide if not auto-increment
      userID,
      total_price: cart.total_price, // Final price from cart after all discounts
      status: 'Pending Payment', // Initial status
      payment_method,
      payment_status: 'Pending',
      // tracking_number will be set once shipped
    };
    const order = await Order.create(orderData, connection);
    const createdOrderID = order.id; // or newOrderID

    // Create Order Items and Update Stock
    for (const item of cartItems) {
      await OrderItem.create({
        orderID: createdOrderID,
        bookID: item.bookID,
        quantity: item.quantity,
        // price_at_purchase: item.price // Good to store price at time of purchase
      }, connection);
      await Book.updateStock(item.bookID, item.quantity, connection); // Decrease stock
    }

    // If coupon was used, mark it as used (increment usage_count)
    if (cart.coupon) {
        await db.query('UPDATE Coupon SET usage_count = usage_count + 1 WHERE code = ?', [cart.coupon], connection);
    }

    // Clear the cart (or mark as 'ordered')
    // Option 1: Delete cart items and reset cart
    await CartItem.clearCart(cart.cartID, connection);
    await Cart.resetCart(cart.cartID, connection); // Resets total_price, coupon, promotion

    // Payment Processing (Conceptual)
    // If QR code, generate QR data. If credit card, integrate with payment gateway.
    // This part is highly dependent on the specific payment services.
    let paymentDetails = {};
    if (payment_method === 'qr_code') {
        paymentDetails.qr_data = `Generated QR data for Order ${createdOrderID} Amount ${orderData.total_price}`;
        // In a real app, you'd update payment_status after confirmation
    } else if (payment_method === 'credit_card') {
        // Placeholder: Simulate call to payment gateway
        // const paymentResult = await processCreditCard(req.body.creditCardDetails, orderData.total_price);
        // if(paymentResult.success) {
        //    await Order.updatePaymentStatus(createdOrderID, 'Paid', connection);
        // } else {
        //    throw new Error('Credit card payment failed.');
        // }
        paymentDetails.message = "Credit card processing initiated. Await confirmation.";
    }


    await connection.commit();
    res.status(201).json({ message: 'Order created successfully', orderID: createdOrderID, paymentDetails });

  } catch (error) {
    await connection.rollback();
    console.error("Order creation error:", error);
    // Send a more user-friendly error message
    const userMessage = error.message.startsWith("Insufficient stock") ? error.message : "Failed to create order. Please try again.";
    res.status(400).json({ message: userMessage, details: error.message }); // Send detailed error for debugging if needed
    // next(error); // Or use the generic error handler
  } finally {
    if (connection) connection.release();
  }
};

export const getOrderById = async (req, res, next) => {
  try {
    const order = await Order.findByIdAndUserId(req.params.id, req.user.userID);
    if (order) {
      const items = await OrderItem.findByOrderId(order.orderID);
      order.items = items;
      // Optionally fetch shipping details if tracking_number exists
      if (order.tracking_number) {
        const shippingInfo = await Shipping.findByTrackingNumber(order.tracking_number);
        order.shippingInfo = shippingInfo;
      }
      res.json(order);
    } else {
      res.status(404);
      throw new Error('Order not found or access denied.');
    }
  } catch (error) {
    next(error);
  }
};

export const getUserOrders = async (req, res, next) => {
  try {
    const orders = await Order.findAllByUserId(req.user.userID);
    // For each order, you might want to fetch items too if needed for summary
    res.json(orders);
  } catch (error) {
    next(error);
  }
};

export const getOrderStatus = async (req, res, next) => {
    try {
        const order = await Order.findByIdAndUserId(req.params.id, req.user.userID);
        if (order) {
            let response = {
                orderID: order.orderID,
                status: order.status,
                payment_status: order.payment_status,
                tracking_number: order.tracking_number,
                shipping_status: null
            };
            if (order.tracking_number) {
                const shippingInfo = await Shipping.findByTrackingNumber(order.tracking_number);
                if (shippingInfo) {
                    response.shipping_status = shippingInfo.shipping_status;
                    response.carrier = shippingInfo.carrier;
                    response.shipping_date = shippingInfo.shipping_date;
                }
            }
            res.json(response);
        } else {
            res.status(404);
            throw new Error('Order not found or access denied.');
        }
    } catch (error) {
        next(error);
    }
};